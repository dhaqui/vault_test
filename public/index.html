<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PayPal Vault â€” Returning + One-click (robust)</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;padding:24px;background:#f6f8fb}
    .card{max-width:900px;margin:0 auto;background:#fff;padding:20px;border-radius:10px;box-shadow:0 4px 18px rgba(0,0,0,.06)}
    .row{display:flex;gap:12px}
    input{padding:8px;border-radius:6px;border:1px solid #ccc;width:100%}
    button{padding:10px 14px;border-radius:8px;border:0;cursor:pointer}
    .primary{background:#0070ba;color:#fff}
    .muted{background:#eef2f6}
    pre{background:#0b1220;color:#e6eef8;padding:12px;border-radius:8px;overflow:auto}
    .info{margin:12px 0;color:#333}
  </style>
</head>
<body>
  <div class="card">
    <h1>PayPal Vault â€” Returning + One-click (robust)</h1>
    <p class="info">VaultãŒã‚ã‚‹å ´åˆã¯ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã‹ãšã€ã‚µãƒ¼ãƒã® Createâ†’Capture ã‚’ä¸€åº¦ã ã‘å‘¼ã‚“ã§æ±ºæ¸ˆå®Œäº†ã«ã—ã¾ã™ã€‚</p>

    <div style="margin-bottom:12px">
      <button id="clearStorage" class="muted">LocalStorage ã‚¯ãƒªã‚¢</button>
    </div>

    <div style="margin-bottom:12px">
      <strong>ä¿å­˜æ¸ˆã¿æƒ…å ±ï¼ˆlocalStorageï¼‰</strong>
      <div id="savedInfo" style="margin-top:8px"></div>
    </div>

    <div id="paypal-button-container" style="margin-bottom:20px; min-height:120px"></div>

    <div style="margin-top:12px">
      <button id="oneclickDirect" class="primary">ãƒ¯ãƒ³ã‚¯ãƒªãƒƒã‚¯æ±ºæ¸ˆï¼ˆVaultãŒã‚ã‚‹å ´åˆï¼‰</button>
    </div>

    <h3 style="margin-top:20px">ãƒ­ã‚° / çµæœ</h3>
    <pre id="log">æº–å‚™ä¸­...</pre>
  </div>

<script>
(async function(){
  const logEl = document.getElementById('log');
  function log(...args){ logEl.textContent = (new Date()).toLocaleTimeString() + ' ' + args.join(' ') + '\n' + logEl.textContent; }

  // load saved
  let customerId = localStorage.getItem('paypal_customer_id') || null;
  let vaultId = localStorage.getItem('paypal_vault_id') || null;
  let payerId = localStorage.getItem('paypal_payer_id') || null;
  let accountId = localStorage.getItem('paypal_account_id') || null;

  function renderSavedInfo(){
    const cont = document.getElementById('savedInfo');
    cont.innerHTML = '';
    if (vaultId) cont.innerHTML += `<div>ğŸ” vaultId: <code>${vaultId}</code></div>`;
    if (customerId) cont.innerHTML += `<div>ğŸ‘¤ customerId: <code>${customerId}</code></div>`;
    if (payerId) cont.innerHTML += `<div>payerId: <code>${payerId}</code></div>`;
    if (accountId) cont.innerHTML += `<div>accountId: <code>${accountId}</code></div>`;
    if (!vaultId && !customerId) cont.innerHTML = '<div>ä¿å­˜ãªã—</div>';
  }
  renderSavedInfo();

  document.getElementById('clearStorage').onclick = () => {
    localStorage.clear();
    customerId = vaultId = payerId = accountId = null;
    renderSavedInfo();
    log('LocalStorage cleared');
  };

  // 1) get config
  const cfgResp = await fetch('/api/config');
  const cfg = await cfgResp.json();
  const CLIENT_ID = cfg.clientId;

  // 2) If customerId present, request id_token with target_customer_id
  let tokenUrl = '/api/generate-client-token';
  if (customerId) tokenUrl += `?customer_id=${encodeURIComponent(customerId)}`;

  const tokenResp = await fetch(tokenUrl);
  const tokenJson = await tokenResp.json();
  const ID_TOKEN = tokenJson.id_token;
  log('id_token obtained');

  // 3) Load PayPal SDK with vault=true and data-user-id-token
  const script = document.createElement('script');
  script.src = `https://www.paypal.com/sdk/js?client-id=${CLIENT_ID}&vault=true&intent=capture&locale=ja_JP&currency=JPY`;
  script.setAttribute('data-user-id-token', ID_TOKEN);
  document.head.appendChild(script);

  script.onload = () => {
    log('PayPal SDK loaded');
    renderButtons();
  };

  script.onerror = (e) => {
    log('PayPal SDK load error', e.message || e);
  };

  // Check vaulted payment tokens (populate vaultId if available)
  async function checkVaultedPayments(){
    if (!customerId) return;
    try {
      const resp = await fetch(`/api/payment-tokens/${encodeURIComponent(customerId)}`);
      const json = await resp.json();
      if (json.payment_tokens && json.payment_tokens.length > 0){
        vaultId = json.payment_tokens[0].id;
        localStorage.setItem('paypal_vault_id', vaultId);
        log('Found vault token:', vaultId);
        renderSavedInfo();
      } else {
        log('No payment_tokens for customer');
      }
    } catch (e) {
      log('Error fetching payment tokens', e.message || e);
    }
  }

  await checkVaultedPayments();

  // Render PayPal Buttons
  function renderButtons(){
    if (!window.paypal) {
      log('paypal SDK not ready');
      return;
    }

    if (vaultId) {
      const desc = document.createElement('div');
      desc.innerHTML = '<strong>âš¡ ãƒ¯ãƒ³ã‚¯ãƒªãƒƒã‚¯ï¼ˆä¿å­˜æ¸ˆã¿ï¼‰ã§æ”¯æ‰•ã„ã¾ã™</strong>';
      document.getElementById('paypal-button-container').appendChild(desc);
    }

    // capturedOrders: map orderId -> capture info, populated when oneclick runs
    const capturedOrders = new Map();

    // Helper: perform oneclick server call (Create->Capture) and return result
    async function callOneclick() {
      const resp = await fetch('/api/orders/oneclick', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ vaultId, customerId, amount: '100', currency: 'JPY' })
      });
      const body = await resp.json();
      if (!resp.ok) throw body;
      return body;
    }

    paypal.Buttons({
      style: { layout: 'vertical', label: 'paypal' },

      // Give SDK the customer_id so it displays saved payment methods
      vault: customerId ? { customer_id: customerId } : undefined,

      /**
       * onClick: Try to perform oneclick here (most common). But createOrder may still be called by SDK,
       * so createOrder must tolerate pre-captured orders (below).
       */
      onClick: async (data, actions) => {
        try {
          if (vaultId) {
            log('onClick: vaultId present â€” calling /api/orders/oneclick');

            // Call oneclick and record orderId -> capture
            let body;
            try {
              body = await callOneclick();
            } catch (errBody) {
              log('oneclick (onClick) failed', JSON.stringify(errBody));
              await actions.reject();
              alert('æ±ºæ¸ˆã«å¤±æ•—ã—ã¾ã—ãŸ: ' + (errBody.error || JSON.stringify(errBody)));
              return;
            }

            log('oneclick (onClick) success, order:', body.orderId, 'capture status:', body.capture?.status);
            if (body.orderId) capturedOrders.set(body.orderId, body.capture || null);

            // Prevent SDK from opening modal
            await actions.reject();

            // Save local storage info
            const cap = body.capture;
            const vaultInfo = cap?.payment_source?.paypal?.attributes?.vault;
            const payerInfo = cap?.payer;
            const paypalSource = cap?.payment_source?.paypal;

            if (vaultInfo?.id) {
              vaultId = vaultInfo.id;
              localStorage.setItem('paypal_vault_id', vaultId);
            }
            if (vaultInfo?.customer?.id) {
              customerId = vaultInfo.customer.id;
              localStorage.setItem('paypal_customer_id', customerId);
            }
            if (payerInfo?.payer_id) {
              payerId = payerInfo.payer_id;
              localStorage.setItem('paypal_payer_id', payerId);
            }
            if (paypalSource?.account_id) {
              accountId = paypalSource.account_id;
              localStorage.setItem('paypal_account_id', accountId);
            }
            renderSavedInfo();

            alert('æ±ºæ¸ˆãŒå®Œäº†ã—ã¾ã—ãŸ');
            return;
          }

          // No vault -> allow normal SDK flow (modal opens)
          await actions.resolve();
        } catch (err) {
          console.error('onClick error', err);
          await actions.reject();
          alert('æ±ºæ¸ˆå‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
        }
      },

      /**
       * createOrder: tolerant implementation.
       * - If order already captured by onClick, return the captured orderId.
       * - If not captured and vaultId exists, perform oneclick here (create+capture) and return orderId.
       * - If no vaultId, perform normal /api/orders create.
       */
      createOrder: async () => {
        try {
          if (vaultId) {
            // If onClick already created+captured, return that orderId immediately
            for (const [orderId] of capturedOrders) {
              log('createOrder: returning pre-captured orderId from onClick:', orderId);
              return orderId;
            }

            // Otherwise, onClick didn't run or didn't finish first. Execute oneclick here.
            log('createOrder: vaultId present but not pre-captured. Calling /api/orders/oneclick from createOrder.');
            const body = await callOneclick();
            if (body.orderId) capturedOrders.set(body.orderId, body.capture || null);
            log('oneclick (createOrder) success', body.orderId);
            return body.orderId;
          }

          // Normal initial flow
          log('createOrder: calling /api/orders for initial flow');
          const resp = await fetch('/api/orders', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ customerId })
          });
          const data = await resp.json();
          if (!resp.ok) throw data;
          log('order created (initial):', data.id);
          return data.id;
        } catch (err) {
          console.error('createOrder error', err);
          throw err;
        }
      },

      /**
       * onApprove: If the order was captured by the server already, skip capture.
       * Otherwise, perform capture as normal.
       */
      onApprove: async (data) => {
        try {
          const orderId = data.orderID || data.orderId;
          log('onApprove called for', orderId);

          if (capturedOrders.has(orderId)) {
            log('Order already captured by server; skipping client-side capture:', orderId);
            return;
          }

          // Not captured yet -> capture via server endpoint
          const resp = await fetch(`/api/orders/${orderId}/capture`, { method: 'POST' });
          const capture = await resp.json();
          if (!resp.ok) {
            // Treat ORDER_ALREADY_CAPTURED as success
            if (capture && capture.name === 'UNPROCESSABLE_ENTITY') {
              const already = (capture.details || []).some(d => d.issue === 'ORDER_ALREADY_CAPTURED');
              if (already) {
                log('Capture attempted but order already captured (treated as success).', capture);
                capturedOrders.set(orderId, capture);
                return;
              }
            }
            throw new Error(capture.error || JSON.stringify(capture));
          }

          log('capture succeeded (onApprove):', capture);
          capturedOrders.set(orderId, capture);

          // Save vault/customer/payer info if present
          const vaultInfo = capture.payment_source?.paypal?.attributes?.vault;
          const payerInfo = capture.payer;
          const paypalSource = capture.payment_source?.paypal;
          if (vaultInfo?.id) {
            vaultId = vaultInfo.id;
            localStorage.setItem('paypal_vault_id', vaultId);
          }
          if (vaultInfo?.customer?.id) {
            customerId = vaultInfo.customer.id;
            localStorage.setItem('paypal_customer_id', customerId);
          }
          if (payerInfo?.payer_id) {
            localStorage.setItem('paypal_payer_id', payerInfo.payer_id);
          }
          if (paypalSource?.account_id) {
            localStorage.setItem('paypal_account_id', paypalSource.account_id);
          }
          renderSavedInfo();

        } catch (err) {
          console.error('onApprove error', err);
        }
      },

      onError: (err) => {
        console.error('PayPal Buttons error', err);
      }

    }).render('#paypal-button-container').then(()=> log('PayPal buttons rendered'));
  }

  // direct oneclick button (same as clicking PayPal button when vault exists)
  document.getElementById('oneclickDirect').onclick = async () => {
    if (!vaultId) return alert('Vault IDãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã¾ãšVaultã‚’ä½œæˆã—ã¦ãã ã•ã„ï¼ˆåˆå›è³¼å…¥ï¼‰ã€‚');
    log('ç›´æ¥ãƒ¯ãƒ³ã‚¯ãƒªãƒƒã‚¯å®Ÿè¡Œ: calling /api/orders/oneclick');
    try {
      const body = await (async () => {
        const resp = await fetch('/api/orders/oneclick', {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify({ vaultId, customerId, amount: '100', currency: 'JPY' })
        });
        const json = await resp.json();
        if (!resp.ok) throw json;
        return json;
      })();

      log('oneclick direct success: ' + JSON.stringify(body));
      const cap = body.capture;
      const vaultInfo = cap?.payment_source?.paypal?.attributes?.vault;
      const payerInfo = cap?.payer;
      const paypalSource = cap?.payment_source?.paypal;
      if (vaultInfo?.id) {
        vaultId = vaultInfo.id;
        localStorage.setItem('paypal_vault_id', vaultId);
      }
      if (vaultInfo?.customer?.id) {
        customerId = vaultInfo.customer.id;
        localStorage.setItem('paypal_customer_id', vaultInfo.customer.id);
      }
      if (payerInfo?.payer_id) {
        payerId = payerInfo.payer_id;
        localStorage.setItem('paypal_payer_id', payerInfo.payer_id);
      }
      if (paypalSource?.account_id) {
        accountId = paypalSource.account_id;
        localStorage.setItem('paypal_account_id', paypalSource.account_id);
      }
      renderSavedInfo();
      alert('æ±ºæ¸ˆå®Œäº†');
    } catch (e) {
      log('oneclick direct error', e.error || e);
      alert('ã‚¨ãƒ©ãƒ¼: ' + (e.error || e));
    }
  };

})();
</script>
</body>
</html>
